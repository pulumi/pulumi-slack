// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package slack

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-slack/sdk/go/slack/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Slack channel
//
// ## Required scopes
//
// This resource requires the following scopes:
//
// If using `bot` tokens:
//
//   - [channels:read](https://api.slack.com/scopes/channels:read)
//     (public channels)
//   - [channels:manage](https://api.slack.com/scopes/channels:manage)
//     (public channels)
//   - [channels:join](https://api.slack.com/scopes/channels:join)
//     (adopting existing public channels)
//   - [groups:read](https://api.slack.com/scopes/groups:read)
//     (private channels)
//   - [groups:write](https://api.slack.com/scopes/groups:write)
//     (private channels)
//
// If using `user` tokens:
//
// - [channels:read](https://api.slack.com/scopes/channels:read) (public channels)
// - [channels:write](https://api.slack.com/scopes/channels:manage) (public channels)
// - [groups:read](https://api.slack.com/scopes/groups:read) (private channels)
// - [groups:write](https://api.slack.com/scopes/groups:write) (private channels)
//
// The Slack API methods used by the resource are:
//
// - [conversations.create](https://api.slack.com/methods/conversations.create)
// - [conversations.join](https://api.slack.com/methods/conversations.join)
// - [conversations.setTopic](https://api.slack.com/methods/conversations.setTopic)
// - [conversations.setPurpose](https://api.slack.com/methods/conversations.setPurpose)
// - [conversations.info](https://api.slack.com/methods/conversations.info)
// - [conversations.members](https://api.slack.com/methods/conversations.members)
// - [conversations.kick](https://api.slack.com/methods/conversations.kick)
// - [conversations.invite](https://api.slack.com/methods/conversations.invite)
// - [conversations.rename](https://api.slack.com/methods/conversations.rename)
// - [conversations.archive](https://api.slack.com/methods/conversations.archive)
// - [conversations.unarchive](https://api.slack.com/methods/conversations.unarchive)
//
// If you get `missingScope` errors while using this resource check the scopes against
// the documentation for the methods above.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-slack/sdk/go/slack"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := slack.NewConversation(ctx, "test", &slack.ConversationArgs{
//				IsPrivate:        pulumi.Bool(true),
//				PermanentMembers: pulumi.StringArray{},
//				Topic:            pulumi.String("The topic for my channel"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-slack/sdk/go/slack"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := slack.NewConversation(ctx, "nonadmin", &slack.ConversationArgs{
//				ActionOnDestroy:  pulumi.String("none"),
//				IsPrivate:        pulumi.Bool(true),
//				PermanentMembers: pulumi.StringArray{},
//				Topic:            pulumi.String("The channel won't be archived on destroy"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-slack/sdk/go/slack"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := slack.NewConversation(ctx, "adopted", &slack.ConversationArgs{
//				ActionOnUpdatePermanentMembers: pulumi.String("none"),
//				AdoptExistingChannel:           pulumi.Bool(true),
//				PermanentMembers:               pulumi.StringArray{},
//				Topic:                          pulumi.String("Adopt existing, don't kick members"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// `slack_conversation` can be imported using the ID of the conversation/channel, e.g.
//
// ```sh
//
//	$ pulumi import slack:index/conversation:Conversation my_conversation C023X7QTFHQ
//
// ```
type Conversation struct {
	pulumi.CustomResourceState

	// indicates whether the
	// conversation should be archived or left behind on destroy. Valid values are
	// `archive | none`. Note that when set to `none` the conversation will be left
	// as it is  and as a result any subsequent runs of pulumi up with the same
	// name  will fail.
	ActionOnDestroy pulumi.StringPtrOutput `pulumi:"actionOnDestroy"`
	// indicate
	// whether the members should be kick of the channel when removed from
	// `permanentMembers`. When set to `none` the user are never kicked, this prevent
	// a side effect on public channels where user that joined the channel are kicked.
	ActionOnUpdatePermanentMembers pulumi.StringPtrOutput `pulumi:"actionOnUpdatePermanentMembers"`
	AdoptExistingChannel           pulumi.BoolPtrOutput   `pulumi:"adoptExistingChannel"`
	// is a unix timestamp.
	Created pulumi.IntOutput `pulumi:"created"`
	// is the user ID of the member that created this channel.
	Creator pulumi.StringOutput `pulumi:"creator"`
	// indicates a conversation is archived. Frozen in time.
	IsArchived pulumi.BoolPtrOutput `pulumi:"isArchived"`
	// represents this conversation as being part of a Shared Channel
	// with a remote organization.
	IsExtShared pulumi.BoolOutput `pulumi:"isExtShared"`
	// will be true if this channel is the "general" channel that includes
	// all regular team members.
	IsGeneral pulumi.BoolOutput `pulumi:"isGeneral"`
	// explains whether this shared channel is shared between Enterprise
	// Grid workspaces within the same organization.
	IsOrgShared pulumi.BoolOutput `pulumi:"isOrgShared"`
	// create a private channel instead of a public one.
	IsPrivate pulumi.BoolOutput `pulumi:"isPrivate"`
	// means the conversation is in some way shared between multiple workspaces.
	IsShared pulumi.BoolOutput `pulumi:"isShared"`
	// name of the public or private channel.
	Name pulumi.StringOutput `pulumi:"name"`
	// user IDs to add to the channel.
	PermanentMembers pulumi.StringArrayOutput `pulumi:"permanentMembers"`
	// purpose of the channel.
	Purpose pulumi.StringPtrOutput `pulumi:"purpose"`
	// topic for the channel.
	Topic pulumi.StringPtrOutput `pulumi:"topic"`
}

// NewConversation registers a new resource with the given unique name, arguments, and options.
func NewConversation(ctx *pulumi.Context,
	name string, args *ConversationArgs, opts ...pulumi.ResourceOption) (*Conversation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IsPrivate == nil {
		return nil, errors.New("invalid value for required argument 'IsPrivate'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Conversation
	err := ctx.RegisterResource("slack:index/conversation:Conversation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConversation gets an existing Conversation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConversation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConversationState, opts ...pulumi.ResourceOption) (*Conversation, error) {
	var resource Conversation
	err := ctx.ReadResource("slack:index/conversation:Conversation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Conversation resources.
type conversationState struct {
	// indicates whether the
	// conversation should be archived or left behind on destroy. Valid values are
	// `archive | none`. Note that when set to `none` the conversation will be left
	// as it is  and as a result any subsequent runs of pulumi up with the same
	// name  will fail.
	ActionOnDestroy *string `pulumi:"actionOnDestroy"`
	// indicate
	// whether the members should be kick of the channel when removed from
	// `permanentMembers`. When set to `none` the user are never kicked, this prevent
	// a side effect on public channels where user that joined the channel are kicked.
	ActionOnUpdatePermanentMembers *string `pulumi:"actionOnUpdatePermanentMembers"`
	AdoptExistingChannel           *bool   `pulumi:"adoptExistingChannel"`
	// is a unix timestamp.
	Created *int `pulumi:"created"`
	// is the user ID of the member that created this channel.
	Creator *string `pulumi:"creator"`
	// indicates a conversation is archived. Frozen in time.
	IsArchived *bool `pulumi:"isArchived"`
	// represents this conversation as being part of a Shared Channel
	// with a remote organization.
	IsExtShared *bool `pulumi:"isExtShared"`
	// will be true if this channel is the "general" channel that includes
	// all regular team members.
	IsGeneral *bool `pulumi:"isGeneral"`
	// explains whether this shared channel is shared between Enterprise
	// Grid workspaces within the same organization.
	IsOrgShared *bool `pulumi:"isOrgShared"`
	// create a private channel instead of a public one.
	IsPrivate *bool `pulumi:"isPrivate"`
	// means the conversation is in some way shared between multiple workspaces.
	IsShared *bool `pulumi:"isShared"`
	// name of the public or private channel.
	Name *string `pulumi:"name"`
	// user IDs to add to the channel.
	PermanentMembers []string `pulumi:"permanentMembers"`
	// purpose of the channel.
	Purpose *string `pulumi:"purpose"`
	// topic for the channel.
	Topic *string `pulumi:"topic"`
}

type ConversationState struct {
	// indicates whether the
	// conversation should be archived or left behind on destroy. Valid values are
	// `archive | none`. Note that when set to `none` the conversation will be left
	// as it is  and as a result any subsequent runs of pulumi up with the same
	// name  will fail.
	ActionOnDestroy pulumi.StringPtrInput
	// indicate
	// whether the members should be kick of the channel when removed from
	// `permanentMembers`. When set to `none` the user are never kicked, this prevent
	// a side effect on public channels where user that joined the channel are kicked.
	ActionOnUpdatePermanentMembers pulumi.StringPtrInput
	AdoptExistingChannel           pulumi.BoolPtrInput
	// is a unix timestamp.
	Created pulumi.IntPtrInput
	// is the user ID of the member that created this channel.
	Creator pulumi.StringPtrInput
	// indicates a conversation is archived. Frozen in time.
	IsArchived pulumi.BoolPtrInput
	// represents this conversation as being part of a Shared Channel
	// with a remote organization.
	IsExtShared pulumi.BoolPtrInput
	// will be true if this channel is the "general" channel that includes
	// all regular team members.
	IsGeneral pulumi.BoolPtrInput
	// explains whether this shared channel is shared between Enterprise
	// Grid workspaces within the same organization.
	IsOrgShared pulumi.BoolPtrInput
	// create a private channel instead of a public one.
	IsPrivate pulumi.BoolPtrInput
	// means the conversation is in some way shared between multiple workspaces.
	IsShared pulumi.BoolPtrInput
	// name of the public or private channel.
	Name pulumi.StringPtrInput
	// user IDs to add to the channel.
	PermanentMembers pulumi.StringArrayInput
	// purpose of the channel.
	Purpose pulumi.StringPtrInput
	// topic for the channel.
	Topic pulumi.StringPtrInput
}

func (ConversationState) ElementType() reflect.Type {
	return reflect.TypeOf((*conversationState)(nil)).Elem()
}

type conversationArgs struct {
	// indicates whether the
	// conversation should be archived or left behind on destroy. Valid values are
	// `archive | none`. Note that when set to `none` the conversation will be left
	// as it is  and as a result any subsequent runs of pulumi up with the same
	// name  will fail.
	ActionOnDestroy *string `pulumi:"actionOnDestroy"`
	// indicate
	// whether the members should be kick of the channel when removed from
	// `permanentMembers`. When set to `none` the user are never kicked, this prevent
	// a side effect on public channels where user that joined the channel are kicked.
	ActionOnUpdatePermanentMembers *string `pulumi:"actionOnUpdatePermanentMembers"`
	AdoptExistingChannel           *bool   `pulumi:"adoptExistingChannel"`
	// indicates a conversation is archived. Frozen in time.
	IsArchived *bool `pulumi:"isArchived"`
	// create a private channel instead of a public one.
	IsPrivate bool `pulumi:"isPrivate"`
	// name of the public or private channel.
	Name *string `pulumi:"name"`
	// user IDs to add to the channel.
	PermanentMembers []string `pulumi:"permanentMembers"`
	// purpose of the channel.
	Purpose *string `pulumi:"purpose"`
	// topic for the channel.
	Topic *string `pulumi:"topic"`
}

// The set of arguments for constructing a Conversation resource.
type ConversationArgs struct {
	// indicates whether the
	// conversation should be archived or left behind on destroy. Valid values are
	// `archive | none`. Note that when set to `none` the conversation will be left
	// as it is  and as a result any subsequent runs of pulumi up with the same
	// name  will fail.
	ActionOnDestroy pulumi.StringPtrInput
	// indicate
	// whether the members should be kick of the channel when removed from
	// `permanentMembers`. When set to `none` the user are never kicked, this prevent
	// a side effect on public channels where user that joined the channel are kicked.
	ActionOnUpdatePermanentMembers pulumi.StringPtrInput
	AdoptExistingChannel           pulumi.BoolPtrInput
	// indicates a conversation is archived. Frozen in time.
	IsArchived pulumi.BoolPtrInput
	// create a private channel instead of a public one.
	IsPrivate pulumi.BoolInput
	// name of the public or private channel.
	Name pulumi.StringPtrInput
	// user IDs to add to the channel.
	PermanentMembers pulumi.StringArrayInput
	// purpose of the channel.
	Purpose pulumi.StringPtrInput
	// topic for the channel.
	Topic pulumi.StringPtrInput
}

func (ConversationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*conversationArgs)(nil)).Elem()
}

type ConversationInput interface {
	pulumi.Input

	ToConversationOutput() ConversationOutput
	ToConversationOutputWithContext(ctx context.Context) ConversationOutput
}

func (*Conversation) ElementType() reflect.Type {
	return reflect.TypeOf((**Conversation)(nil)).Elem()
}

func (i *Conversation) ToConversationOutput() ConversationOutput {
	return i.ToConversationOutputWithContext(context.Background())
}

func (i *Conversation) ToConversationOutputWithContext(ctx context.Context) ConversationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationOutput)
}

// ConversationArrayInput is an input type that accepts ConversationArray and ConversationArrayOutput values.
// You can construct a concrete instance of `ConversationArrayInput` via:
//
//	ConversationArray{ ConversationArgs{...} }
type ConversationArrayInput interface {
	pulumi.Input

	ToConversationArrayOutput() ConversationArrayOutput
	ToConversationArrayOutputWithContext(context.Context) ConversationArrayOutput
}

type ConversationArray []ConversationInput

func (ConversationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Conversation)(nil)).Elem()
}

func (i ConversationArray) ToConversationArrayOutput() ConversationArrayOutput {
	return i.ToConversationArrayOutputWithContext(context.Background())
}

func (i ConversationArray) ToConversationArrayOutputWithContext(ctx context.Context) ConversationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationArrayOutput)
}

// ConversationMapInput is an input type that accepts ConversationMap and ConversationMapOutput values.
// You can construct a concrete instance of `ConversationMapInput` via:
//
//	ConversationMap{ "key": ConversationArgs{...} }
type ConversationMapInput interface {
	pulumi.Input

	ToConversationMapOutput() ConversationMapOutput
	ToConversationMapOutputWithContext(context.Context) ConversationMapOutput
}

type ConversationMap map[string]ConversationInput

func (ConversationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Conversation)(nil)).Elem()
}

func (i ConversationMap) ToConversationMapOutput() ConversationMapOutput {
	return i.ToConversationMapOutputWithContext(context.Background())
}

func (i ConversationMap) ToConversationMapOutputWithContext(ctx context.Context) ConversationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConversationMapOutput)
}

type ConversationOutput struct{ *pulumi.OutputState }

func (ConversationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Conversation)(nil)).Elem()
}

func (o ConversationOutput) ToConversationOutput() ConversationOutput {
	return o
}

func (o ConversationOutput) ToConversationOutputWithContext(ctx context.Context) ConversationOutput {
	return o
}

// indicates whether the
// conversation should be archived or left behind on destroy. Valid values are
// `archive | none`. Note that when set to `none` the conversation will be left
// as it is  and as a result any subsequent runs of pulumi up with the same
// name  will fail.
func (o ConversationOutput) ActionOnDestroy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringPtrOutput { return v.ActionOnDestroy }).(pulumi.StringPtrOutput)
}

// indicate
// whether the members should be kick of the channel when removed from
// `permanentMembers`. When set to `none` the user are never kicked, this prevent
// a side effect on public channels where user that joined the channel are kicked.
func (o ConversationOutput) ActionOnUpdatePermanentMembers() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringPtrOutput { return v.ActionOnUpdatePermanentMembers }).(pulumi.StringPtrOutput)
}

func (o ConversationOutput) AdoptExistingChannel() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolPtrOutput { return v.AdoptExistingChannel }).(pulumi.BoolPtrOutput)
}

// is a unix timestamp.
func (o ConversationOutput) Created() pulumi.IntOutput {
	return o.ApplyT(func(v *Conversation) pulumi.IntOutput { return v.Created }).(pulumi.IntOutput)
}

// is the user ID of the member that created this channel.
func (o ConversationOutput) Creator() pulumi.StringOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringOutput { return v.Creator }).(pulumi.StringOutput)
}

// indicates a conversation is archived. Frozen in time.
func (o ConversationOutput) IsArchived() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolPtrOutput { return v.IsArchived }).(pulumi.BoolPtrOutput)
}

// represents this conversation as being part of a Shared Channel
// with a remote organization.
func (o ConversationOutput) IsExtShared() pulumi.BoolOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolOutput { return v.IsExtShared }).(pulumi.BoolOutput)
}

// will be true if this channel is the "general" channel that includes
// all regular team members.
func (o ConversationOutput) IsGeneral() pulumi.BoolOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolOutput { return v.IsGeneral }).(pulumi.BoolOutput)
}

// explains whether this shared channel is shared between Enterprise
// Grid workspaces within the same organization.
func (o ConversationOutput) IsOrgShared() pulumi.BoolOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolOutput { return v.IsOrgShared }).(pulumi.BoolOutput)
}

// create a private channel instead of a public one.
func (o ConversationOutput) IsPrivate() pulumi.BoolOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolOutput { return v.IsPrivate }).(pulumi.BoolOutput)
}

// means the conversation is in some way shared between multiple workspaces.
func (o ConversationOutput) IsShared() pulumi.BoolOutput {
	return o.ApplyT(func(v *Conversation) pulumi.BoolOutput { return v.IsShared }).(pulumi.BoolOutput)
}

// name of the public or private channel.
func (o ConversationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// user IDs to add to the channel.
func (o ConversationOutput) PermanentMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringArrayOutput { return v.PermanentMembers }).(pulumi.StringArrayOutput)
}

// purpose of the channel.
func (o ConversationOutput) Purpose() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringPtrOutput { return v.Purpose }).(pulumi.StringPtrOutput)
}

// topic for the channel.
func (o ConversationOutput) Topic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Conversation) pulumi.StringPtrOutput { return v.Topic }).(pulumi.StringPtrOutput)
}

type ConversationArrayOutput struct{ *pulumi.OutputState }

func (ConversationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Conversation)(nil)).Elem()
}

func (o ConversationArrayOutput) ToConversationArrayOutput() ConversationArrayOutput {
	return o
}

func (o ConversationArrayOutput) ToConversationArrayOutputWithContext(ctx context.Context) ConversationArrayOutput {
	return o
}

func (o ConversationArrayOutput) Index(i pulumi.IntInput) ConversationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Conversation {
		return vs[0].([]*Conversation)[vs[1].(int)]
	}).(ConversationOutput)
}

type ConversationMapOutput struct{ *pulumi.OutputState }

func (ConversationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Conversation)(nil)).Elem()
}

func (o ConversationMapOutput) ToConversationMapOutput() ConversationMapOutput {
	return o
}

func (o ConversationMapOutput) ToConversationMapOutputWithContext(ctx context.Context) ConversationMapOutput {
	return o
}

func (o ConversationMapOutput) MapIndex(k pulumi.StringInput) ConversationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Conversation {
		return vs[0].(map[string]*Conversation)[vs[1].(string)]
	}).(ConversationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConversationInput)(nil)).Elem(), &Conversation{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConversationArrayInput)(nil)).Elem(), ConversationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConversationMapInput)(nil)).Elem(), ConversationMap{})
	pulumi.RegisterOutputType(ConversationOutput{})
	pulumi.RegisterOutputType(ConversationArrayOutput{})
	pulumi.RegisterOutputType(ConversationMapOutput{})
}
